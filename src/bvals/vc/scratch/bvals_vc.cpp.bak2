//========================================================================================
// Athena++ astrophysical MHD code
// Copyright(C) 2014 James M. Stone <jmstone@princeton.edu> and other code contributors
// Licensed under the 3-clause BSD License, see LICENSE file for details
//========================================================================================
//! \file bvals_cc.cpp
//  \brief functions that apply BCs for VERTEX_CENTERED variables

// C headers

// C++ headers
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <cstring>    // memcpy()
#include <sstream>    // stringstream
#include <stdexcept>  // runtime_error
#include <string>     // c_str()

// Athena++ headers
#include "../../athena.hpp"
#include "../../athena_arrays.hpp"
#include "../../coordinates/coordinates.hpp"
#include "../../eos/eos.hpp"
#include "../../field/field.hpp"
#include "../../globals.hpp"
#include "../../hydro/hydro.hpp"
#include "../../mesh/mesh.hpp"
#include "../../parameter_input.hpp"
#include "../../utils/buffer_utils.hpp"
#include "../bvals.hpp"
#include "bvals_vc.hpp"

// BD: debug
#include "../../lagrange_interp.hpp"
//-

// MPI header
#ifdef MPI_PARALLEL
#include <mpi.h>
#endif

// constructor

VertexCenteredBoundaryVariable::VertexCenteredBoundaryVariable(
    MeshBlock *pmb, AthenaArray<Real> *var, AthenaArray<Real> *coarse_var,
    AthenaArray<Real> *var_flux)
    : BoundaryVariable(pmb), var_vc(var), coarse_buf(coarse_var), x1flux(var_flux[X1DIR]),
      x2flux(var_flux[X2DIR]), x3flux(var_flux[X3DIR]), nl_(0), nu_(var->GetDim4() -1),
      flip_across_pole_(nullptr) {
  // VertexCenteredBoundaryVariable should only be used w/ 4D or 3D (nx4=1) AthenaArray
  // For now, assume that full span of 4th dim of input AthenaArray should be used:
  // ---> get the index limits directly from the input AthenaArray
  // <=nu_ (inclusive), <nx4 (exclusive)
  if (nu_ < 0) {
    std::stringstream msg;
    msg << "### FATAL ERROR in VertexCenteredBoundaryVariable constructor" << std::endl
        << "An 'AthenaArray<Real> *var' of nx4_ = " << var->GetDim4() << " was passed\n"
        << "Should be nx4 >= 1 (likely uninitialized)." << std::endl;
    ATHENA_ERROR(msg);
  }

  InitBoundaryData(bd_var_, BoundaryQuantity::vc);
#ifdef MPI_PARALLEL
  // KGF: dead code, leaving for now:
  // cc_phys_id_ = pbval_->ReserveTagVariableIDs(1);
  vc_phys_id_ = pbval_->bvars_next_phys_id_;
#endif
  if (pmy_mesh_->multilevel) { // SMR or AMR
    // InitBoundaryData(bd_var_flcor_, BoundaryQuantity::cc_flcor);
#ifdef MPI_PARALLEL
    // cc_flx_phys_id_ = cc_phys_id_ + 1;
#endif
  }

// VC
//   if (SHEARING_BOX) {
// #ifdef MPI_PARALLEL
//     shear_cc_phys_id_ = cc_phys_id_ + 2;
// #endif
//     if (pbval_->ShBoxCoord_ == 1) {
//       int nc2 = pmb->ncells2;
//       int nc3 = pmb->ncells3;
//       for (int upper=0; upper<2; upper++) {
//         if (pbval_->is_shear[upper]) {
//           shear_cc_[upper].NewAthenaArray(nu_+1, nc3, nc2, NGHOST);
//           shear_flx_cc_[upper].NewAthenaArray(nc2);

//           // TODO(KGF): the rest of this should be a part of InitBoundaryData()

//           // attach corner cells from L/R side
//           int size = (pmb->block_size.nx2 + NGHOST)*pbval_->ssize_*(nu_ + 1);
//           for (int n=0; n<2; n++) {
//             shear_bd_var_[upper].send[n] = new Real[size];
//             shear_bd_var_[upper].recv[n] = new Real[size];
//             shear_bd_var_[upper].flag[n] = BoundaryStatus::waiting;
// #ifdef MPI_PARALLEL
//             shear_bd_var_[upper].req_send[n] = MPI_REQUEST_NULL;
//             shear_bd_var_[upper].req_recv[n] = MPI_REQUEST_NULL;
// #endif
//           }
//           // corner cells only
//           size = NGHOST*pbval_->ssize_*(nu_ + 1);
//           for (int n=2; n<4; n++) {
//             shear_bd_var_[upper].send[n] = new Real[size];
//             shear_bd_var_[upper].recv[n] = new Real[size];
//             shear_bd_var_[upper].flag[n] = BoundaryStatus::waiting;
// #ifdef MPI_PARALLEL
//             shear_bd_var_[upper].req_send[n] = MPI_REQUEST_NULL;
//             shear_bd_var_[upper].req_recv[n] = MPI_REQUEST_NULL;
// #endif
//           }
//         } // end "if is a shearing boundary"
//       }  // end loop over inner, outer shearing boundaries
//     } // end "if (pbval_->ShBoxCoord_ == 1)"
//   } // end shearing box component of ctor
}

// destructor

VertexCenteredBoundaryVariable::~VertexCenteredBoundaryVariable() {
  DestroyBoundaryData(bd_var_);
  if (pmy_mesh_->multilevel)
    DestroyBoundaryData(bd_var_flcor_);

  // // TODO(KGF): this should be a part of DestroyBoundaryData()
  // if (SHEARING_BOX) {
  //   for (int upper=0; upper<2; upper++) {
  //     if (pbval_->is_shear[upper]) { // if true for shearing inner blocks
  //       for (int n=0; n<4; n++) {
  //         delete[] shear_bd_var_[upper].send[n];
  //         delete[] shear_bd_var_[upper].recv[n];
  //       }
  //     }
  //   }
  // }
}

void ErrorIfPolarNotImplemented(const NeighborBlock& nb) {
  // BD: TODO implement polar coordinates
  if (nb.polar) {
  std::stringstream msg;
  msg << "### FATAL ERROR" << std::endl
      << "Polar coordinates not implemented for vertex-centered." << std::endl;
  ATHENA_ERROR(msg);
  }
  return;
}

void ErrorIfShearingBoxNotImplemented() {
  // BD: TODO implement shearing box
  if (SHEARING_BOX){
    std::stringstream msg;
    msg << "### FATAL ERROR" << std::endl
        << "Shearing box not implemented for vertex-centered." << std::endl;
    ATHENA_ERROR(msg);
  }
}

int VertexCenteredBoundaryVariable::ComputeVariableBufferSize(const NeighborIndexes& ni,
                                                              int cng) {
  coutYellow("VertexCenteredBoundaryVariable::ComputeVariableBufferSize\n");
  MeshBlock *pmb = pmy_block_;
  int cng1, cng2, cng3;
  cng1 = cng;
  cng2 = cng*(pmb->block_size.nx2 > 1 ? 1 : 0);
  cng3 = cng*(pmb->block_size.nx3 > 1 ? 1 : 0);

  // BD: TODO- CALCULATE CAREFULLY
  int size = ((ni.ox1 == 0) ? pmb->nverts1 : NGHOST)
    *((ni.ox2 == 0) ? pmb->nverts2 : NGHOST)
    *((ni.ox3 == 0) ? pmb->nverts3 : NGHOST);

  if (pmy_mesh_->multilevel) {
    int f2c = ((ni.ox1 == 0) ? ((pmb->block_size.nx1+1)/2) : NGHOST)
      *((ni.ox2 == 0) ? ((pmb->block_size.nx2+1)/2) : NGHOST)
      *((ni.ox3 == 0) ? ((pmb->block_size.nx3+1)/2) : NGHOST);
    int c2f = ((ni.ox1 == 0) ?((pmb->block_size.nx1+1)/2 + cng1) : cng)
      *((ni.ox2 == 0) ? ((pmb->block_size.nx2+1)/2 + cng2) : cng)
      *((ni.ox3 == 0) ? ((pmb->block_size.nx3+1)/2 + cng3) : cng);
    size = std::max(size, c2f);
    size = std::max(size, f2c);
  }
  size *= nu_ + 1;

  printf("size = %d\n", size);

  // DOUBLE FOR DEBUG
  return 4 * size;
}

//----------------------------------------------------------------------------------------
//! \fn int VertexCenteredBoundaryVariable::LoadBoundaryBufferSameLevel(Real *buf,
//                                                                const NeighborBlock& nb)
//  \brief Set vertex-centered boundary buffers for sending to a block on the same level

int VertexCenteredBoundaryVariable::LoadBoundaryBufferSameLevel(Real *buf,
                                                                const NeighborBlock& nb) {
  coutYellow("VertexCenteredBoundaryVariable::LoadBoundaryBufferSameLevel\n");
  nb.print_all();

  MeshBlock *pmb = pmy_block_;
  int si, sj, sk, ei, ej, ek;
  int p = 0;
  AthenaArray<Real> &var = *var_vc;

  // shared vertex is packed
  si = (nb.ni.ox1 > 0) ? pmb->ige : pmb->ivs;
  ei = (nb.ni.ox1 < 0) ? pmb->igs : pmb->ive;

  sj = (nb.ni.ox2 > 0) ? pmb->jge : pmb->jvs;
  ej = (nb.ni.ox2 < 0) ? pmb->jgs : pmb->jve;

  sk = (nb.ni.ox3 > 0) ? pmb->kge : pmb->kvs;
  ek = (nb.ni.ox3 < 0) ? pmb->kgs : pmb->kve;

  BufferUtility::PackData(var, buf, nl_, nu_, si, ei, sj, ej, sk, ek, p);

  // if ((nb.ni.ox1 == -1) and (nb.ni.ox2 == -1))
  //   Q();

  // BD: debug: lagrange interp
  if (false) {
    coutBoldBlue("\nlagrange_interp scratch\n");

    Coordinates *pco = pmb->pcoord;

    // settings for interpolator
    const int interp_order = 4;
    const int interp_dim = 1;

    Real origin[1] = {pco->x1f(0)};
    Real delta[1] = {pco->dx1v(0)};
    int size[1] = {pmb->block_size.nx1 + 2*(NGHOST) + 1};

    // target coord
    Real coord[1] = {pco->x1f(2) + delta[0] / 2.};
    printf("coord: %1.18f\n", coord[0]);

    // set up n-dimensional interpolator
    LagrangeInterpND<interp_order, interp_dim> * pinterp = nullptr;

    pinterp = new LagrangeInterpND<interp_order, interp_dim>(origin, delta, size, coord);

    // test interpolation to point
    AthenaArray<Real> mySrc, myDst;

    int iv = 0; // solution component
    mySrc.InitWithShallowSlice(const_cast<AthenaArray<Real>&>(var), iv, 1);
    // myDst.InitWithShallowSlice(const_cast<AthenaArray<Real>&>(var), iv, 1);

    myDst.NewAthenaArray(var.GetDim1());

    // attempt interp.
    mySrc.Fill(200);
    mySrc(0, 0, 0, 0) = 10;
    mySrc(0, 0, 0, 1) = 11;
    mySrc(0, 0, 0, 2) = 12;
    myDst(0, 0, 0, 0) = pinterp->eval(mySrc.data());

    // inspect
    coutBoldBlue("mySrc:\n");
    mySrc.print_all();

    coutBoldBlue("myDst:\n");
    myDst.print_all();


    // clean-up
    // for (int i = 0; i < n; ++i) {
    //   delete pinterp[i];
    // }
    delete pinterp;
    //--

    Q();
  }

  return p;
}


//----------------------------------------------------------------------------------------
//! \fn int VertexCenteredBoundaryVariable::LoadBoundaryBufferToCoarser(Real *buf,
//                                                                const NeighborBlock& nb)
//  \brief Set vertex-centered boundary buffers for sending to a block on the coarser level

int VertexCenteredBoundaryVariable::LoadBoundaryBufferToCoarser(Real *buf,
                                                                const NeighborBlock& nb) {
  coutYellow("VertexCenteredBoundaryVariable::LoadBoundaryBufferToCoarser\n");
  nb.print_all();

  MeshBlock *pmb = pmy_block_;
  MeshRefinement *pmr = pmb->pmr;
  int si, sj, sk, ei, ej, ek;

  AthenaArray<Real> &var = *var_vc;
  AthenaArray<Real> &coarse_var = *coarse_buf;

  // vertices that are shared with adjacent MeshBlocks are to be copied to coarser level
  int ng = NGHOST;
  si = (nb.ni.ox1 > 0) ? (pmb->civ - ng) : pmb->cis;
  ei = (nb.ni.ox1 < 0) ? (pmb->cis + ng) : pmb->civ;

  sj = (nb.ni.ox2 > 0) ? (pmb->cjv - ng) : pmb->cjs;
  ej = (nb.ni.ox2 < 0) ? (pmb->cjs + ng) : pmb->cjv;

  sk = (nb.ni.ox3 > 0) ? (pmb->ckv - ng) : pmb->cks;
  ek = (nb.ni.ox3 < 0) ? (pmb->cks + ng) : pmb->ckv;


  int p = 0;

  coutBoldRed("var_vc\n");
  var.print_all();

  coutBoldRed("coarse_buf\n");
  coarse_var.print_all();

  pmr->RestrictVertexCenteredValues(var, coarse_var, nl_, nu_, si, ei, sj, ej, sk, ek);
  coutBoldRed("coarse_buf, buf");
  BufferUtility::PackData(coarse_var, buf, nl_, nu_, si, ei, sj, ej, sk, ek, p);

  return p;
}

//----------------------------------------------------------------------------------------
//! \fn int VertexCenteredBoundaryVariable::LoadBoundaryBufferToFiner(Real *buf,
//                                                                const NeighborBlock& nb)
//  \brief Set vertex-centered boundary buffers for sending to a block on the finer level

int VertexCenteredBoundaryVariable::LoadBoundaryBufferToFiner(Real *buf,
                                                              const NeighborBlock& nb) {
  coutYellow("VertexCenteredBoundaryVariable::LoadBoundaryBufferToFiner\n");
  nb.print_all();

  MeshBlock *pmb = pmy_block_;
  int si, sj, sk, ei, ej, ek;
  int cn = pmb->cnghost - 1;
  AthenaArray<Real> &var = *var_vc;

  // si = (nb.ni.ox1 > 0) ? (pmb->ie - cn) : pmb->is;
  // ei = (nb.ni.ox1 < 0) ? (pmb->is + cn) : pmb->ie;
  // sj = (nb.ni.ox2 > 0) ? (pmb->je - cn) : pmb->js;
  // ej = (nb.ni.ox2 < 0) ? (pmb->js + cn) : pmb->je;
  // sk = (nb.ni.ox3 > 0) ? (pmb->ke - cn) : pmb->ks;
  // ek = (nb.ni.ox3 < 0) ? (pmb->ks + cn) : pmb->ke;

  si = (nb.ni.ox1 > 0) ? (pmb->iv - 1 - cn) : pmb->is;
  ei = (nb.ni.ox1 < 0) ? (pmb->is + 1 + cn) : pmb->iv;

  sj = (nb.ni.ox2 > 0) ? (pmb->je - 1 - cn) : pmb->js;
  ej = (nb.ni.ox2 < 0) ? (pmb->js + 1 + cn) : pmb->jv;

  sk = (nb.ni.ox3 > 0) ? (pmb->ke - 1 - cn) : pmb->ks;
  ek = (nb.ni.ox3 < 0) ? (pmb->ks + 1 + cn) : pmb->kv;
  // send the data first and later prolongate on the target block

  // need to add edges for faces, add corners for edges
  if (nb.ni.ox1 == 0) {
    if (nb.ni.fi1 == 1)   si += pmb->block_size.nx1/2;
    else            ei -= pmb->block_size.nx1/2 - pmb->cnghost;
  }
  if (nb.ni.ox2 == 0 && pmb->block_size.nx2 > 1) {
    if (nb.ni.ox1 != 0) {
      if (nb.ni.fi1 == 1) sj += pmb->block_size.nx2/2 - pmb->cnghost;
      else          ej -= pmb->block_size.nx2/2 - pmb->cnghost;
    } else {
      if (nb.ni.fi2 == 1) sj += pmb->block_size.nx2/2 - pmb->cnghost;
      else          ej -= pmb->block_size.nx2/2 - pmb->cnghost;
    }
  }
  if (nb.ni.ox3 == 0 && pmb->block_size.nx3 > 1) {
    if (nb.ni.ox1 != 0 && nb.ni.ox2 != 0) {
      if (nb.ni.fi1 == 1) sk += pmb->block_size.nx3/2 - pmb->cnghost;
      else          ek -= pmb->block_size.nx3/2 - pmb->cnghost;
    } else {
      if (nb.ni.fi2 == 1) sk += pmb->block_size.nx3/2 - pmb->cnghost;
      else          ek -= pmb->block_size.nx3/2 - pmb->cnghost;
    }
  }

  // modify for vc [this needs to be checked for 2/3d]
  // int io = 1; // offset for x1 to avoid edge vertices

  // if (nb.ni.ox1 > 0) {
  //   si = pmb->iv - cn - io;
  //   ei = pmb->iv - io;
  // } else {
  //   si = pmb->is + io;
  //   ei = pmb->is + cn + io;
  // }

  si = (nb.ni.ox1 > 0) ? (pmb->iv - 1 - cn) : pmb->is;
  ei = (nb.ni.ox1 < 0) ? (pmb->is + 1 + cn) : pmb->iv;

  sj = (nb.ni.ox2 > 0) ? (pmb->je - 1 - cn) : pmb->js;
  ej = (nb.ni.ox2 < 0) ? (pmb->js + 1 + cn) : pmb->jv;

  sk = (nb.ni.ox3 > 0) ? (pmb->ke - 1 - cn) : pmb->ks;
  ek = (nb.ni.ox3 < 0) ? (pmb->ks + 1 + cn) : pmb->kv;

  int p = 0;

  coutBoldRed("var_vc, buf");
  BufferUtility::PackData(var, buf, nl_, nu_, si, ei, sj, ej, sk, ek, p);

  // printf("x1f: ");
  // pmb->pcoord->x1f.print_data("%1.2f");

  coutBoldRed("MB::UWIL gid = ");
  printf("%d\n", pmb->gid);

  // if (nb.ni.ox1 > 0)
  //   Q();
  // if ((nb.ni.ox1 == 1) and (nb.ni.ox2 == -1))
  //   Q();

  return p;
}


//----------------------------------------------------------------------------------------
//! \fn void VertexCenteredBoundaryVariable::SetBoundarySameLevel(Real *buf,
//                                                              const NeighborBlock& nb)
//  \brief Set vertex-centered boundary received from a block on the same level

void VertexCenteredBoundaryVariable::SetBoundarySameLevel(Real *buf,
                                                          const NeighborBlock& nb) {

  coutYellow("VertexCenteredBoundaryVariable::SetBoundarySameLevel\n");
  nb.print_all();

  MeshBlock *pmb = pmy_block_;
  int si, sj, sk, ei, ej, ek;
  AthenaArray<Real> &var = *var_vc;
  int p = 0;

  si = ei = sj = ej = sk = ek = 0;

  // BD: TODO implement
  ErrorIfPolarNotImplemented(nb);
  ErrorIfShearingBoxNotImplemented();

  //----------------------------------------------------------------------------
  // could unpack based on dimensionality
  // shared data unpacked with add, isolated with overwrite
  // if (pmb->block_size.nx3 > 1) {
  //   // ...
  // } else if (pmb->block_size.nx2 > 1) {
  //   // ...
  // } else {
  //   // shared vertex
  //   if (nb.ni.ox1 < 0) {   // neighbor is to the left
  //     si = ei = pmb->ive;
  //   } else {            // neighbor is to the right
  //     si = ei = pmb->ivs;
  //   }
  //   BufferUtility::UnpackDataAdd(buf, var, nl_, nu_,
  //                                si, ei, sj, ej, sk, ek, p);
  //   // isolated vertices
  //   if (nb.ni.ox1 < 0) {
  //     si = pmb->ips; ei = pmb->ipe;
  //   } else {
  //     si = pmb->ims; ei = pmb->ime;
  //   }
  //   BufferUtility::UnpackData(buf, var, nl_, nu_, si, ei, sj, ej, sk, ek, p);
  // }
  //----------------------------------------------------------------------------


  // unpack all data additively
  // defer imposition (via suitable averaging) of consistency condition
  if (nb.ni.ox1 == 0) {
    si = pmb->ivs; ei = pmb->ive;
  } else if (nb.ni.ox1 > 0) {
    si = pmb->ive; ei = pmb->ipe;
  } else {
    si = pmb->ims; ei = pmb->ivs;
  }

  if (nb.ni.ox2 == 0) {
    sj = pmb->jvs; ej = pmb->jve;
  } else if (nb.ni.ox2 > 0) {
    sj = pmb->jve; ej = pmb->jpe;
  } else {
    sj = pmb->jms; ej = pmb->jvs;
  }

  if (nb.ni.ox3 == 0) {
    sk = pmb->kvs; ek = pmb->kve;
  } else if (nb.ni.ox3 > 0) {
    sk = pmb->kve; ek = pmb->kpe;
  } else {
    sk = pmb->kms; ek = pmb->kvs;
  }

  //////////////////////////////////////////////////////////////////////////////
  // BD: debug - populate based on solution
  if (FILL_WAVE_BND_SL) {
    // populate only faces [only one oxi is non-zero]
    // pmb->DebugWaveMeshBlock(var, si, ei, sj, ej, sk, ek, true);
      pmb->DebugWaveMeshBlock(var, si, ei, sj, ej, sk, ek, true);
    if (std::abs(nb.ni.ox1) + std::abs(nb.ni.ox2) + std::abs(nb.ni.ox3) == 1) {
    }

    // populate only edges [only two oxi are non-zero]
    if (std::abs(nb.ni.ox1) + std::abs(nb.ni.ox2) + std::abs(nb.ni.ox3) == 2) {
      //
      //pmb->DebugWaveMeshBlock(var, si, ei, sj, ej, sk, ek, true);
    }

    // populate only corners [oxi != 0]
    if (std::abs(nb.ni.ox1) + std::abs(nb.ni.ox2) + std::abs(nb.ni.ox3) == 3) {
    }

    var.print_all();
    // Q();
  } else {
    BufferUtility::UnpackDataAdd(buf, var, nl_, nu_, si, ei, sj, ej, sk, ek, p);
    // BufferUtility::UnpackData(buf, var, nl_, nu_, si, ei, sj, ej, sk, ek, p);
  }
  //////////////////////////////////////////////////////////////////////////////

  return;
}

//----------------------------------------------------------------------------------------
//! \fn void VertexCenteredBoundaryVariable::SetBoundaryFromCoarser(Real *buf,
//                                                                const NeighborBlock& nb)
//  \brief Set vertex-centered prolongation buffer received from a block on a coarser level

void VertexCenteredBoundaryVariable::SetBoundaryFromCoarser(Real *buf,
                                                            const NeighborBlock& nb) {
  // populating from a coarser level; do not touch shared vertices
  coutYellow("VertexCenteredBoundaryVariable::SetBoundaryFromCoarser\n");
  nb.print_all();

  MeshBlock *pmb = pmy_block_;
  int si, sj, sk, ei, ej, ek;
  int cng = pmb->cnghost;
  AthenaArray<Real> &coarse_var = *coarse_buf;

  if (nb.ni.ox1 == 0) {
    si = pmb->cis, ei = pmb->cie;
    if ((pmb->loc.lx1 & 1LL) == 0LL) ei += cng;
    else                             si -= cng;
  } else if (nb.ni.ox1 > 0)  {
    si = pmb->cie + 1,   ei = pmb->cie + cng;
  } else {
    si = pmb->cis - cng, ei = pmb->cis - 1;
  }
  if (nb.ni.ox2 == 0) {
    sj = pmb->cjs, ej = pmb->cje;
    if (pmb->block_size.nx2 > 1) {
      if ((pmb->loc.lx2 & 1LL) == 0LL) ej += cng;
      else                             sj -= cng;
    }
  } else if (nb.ni.ox2 > 0) {
    sj = pmb->cje + 1,   ej = pmb->cje + cng;
  } else {
    sj = pmb->cjs - cng, ej = pmb->cjs - 1;
  }
  if (nb.ni.ox3 == 0) {
    sk = pmb->cks, ek = pmb->cke;
    if (pmb->block_size.nx3 > 1) {
      if ((pmb->loc.lx3 & 1LL) == 0LL) ek += cng;
      else                             sk -= cng;
    }
  } else if (nb.ni.ox3 > 0)  {
    sk = pmb->cke + 1,   ek = pmb->cke + cng;
  } else {
    sk = pmb->cks - cng, ek = pmb->cks - 1;
  }

  // modify for vc [this needs to be checked for 2/3d]
  // if (nb.ni.ox1 > 0)  {
  //   si = pmb->civ + 1,   ei = pmb->civ + cng;
  // } else {
  //   si = pmb->cis - cng, ei = pmb->cis - 1;
  // }

  int p = 0;
  // BD: TODO implement
  // if (nb.polar) {
  ErrorIfPolarNotImplemented(nb);
  // } else {
  //   BufferUtility::UnpackData(buf, coarse_var, nl_, nu_,
  //                             si, ei, sj, ej, sk, ek, p);
  // }

  // AthenaArray<Real> &var = *var_vc;

  // coarse_var.print_all();
  // var.print_all();
  // Q();

  // write like this to regroup idx logic for debug
  if (!FILL_WAVE_BND_FRC)
    BufferUtility::UnpackData(buf, coarse_var, nl_, nu_,
                              si, ei, sj, ej, sk, ek, p);

  //////////////////////////////////////////////////////////////////////////////
  // BD: debug - populate based on solution
  // [note we directly modify fund. not coarse]

  bool flag = false;

  // [1d] modifies si, ei
  if (nb.ni.ox1 == 0) {
    //
    // (si, ei)= (cis, cie)
    if ((pmb->loc.lx1 & 1LL) == 0LL) {
      //
      // (si, ei) = (cis, cie + cnghost)
      si = pmb->ivs;
      ei = pmb->ipe;
    } else {
      //
      // (si, ei) = (cis - cnghost, cie)
      si = pmb->ims;
      ei = pmb->ive;
    }
  } else if (nb.ni.ox1 > 0)  {
    //
    // (si, ei) = (cie + 1, cie + cnghost)
    si = pmb->ips;
    ei = pmb->ipe;
  } else {
    //
    // (si, ei) = (cis - cnghost, cis - 1)
    si = pmb->ims;
    ei = pmb->ime;
  }

  // [2d] modifies sj, ej
  if (nb.ni.ox2 == 0) {
    //
    // (sj, ej) = (cjs, cje)
    if (pmb->block_size.nx2 > 1) {
      if ((pmb->loc.lx2 & 1LL) == 0LL) {
        //
        // (sj, ej) = (cjs, cje + cnghost)
        sj = pmb->jvs;
        ej = pmb->jpe;
      } else {
        //
        // (sj, ej) = (cjs - cnghost, cje)
        sj = pmb->jms;
        ej = pmb->jve;
      }
    }
  } else if (nb.ni.ox2 > 0) {
    //
    // (sj, ej) = (cje + 1, cje + cnghost)
    sj = pmb->jps;
    ej = pmb->jpe;
  } else {
    //
    // (sj, ej) = (cjs - cnghost, cjs - 1)
    sj = pmb->jms;
    ej = pmb->jme;
  }

  // [3d] modifies sk, ek
  if (nb.ni.ox3 == 0) {
    //
    // (sk, ek) = (cks, cke)
    if (pmb->block_size.nx3 > 1) {
      if ((pmb->loc.lx3 & 1LL) == 0LL) {
        //
        // (sk, ek) = (cks, cke + cnghost)
        sk = pmb->kvs;
        ek = pmb->kpe;
      } else {
        //
        // (sk, ek) = (cks - cnghost, cke)
        sk = pmb->kms;
        ek = pmb->kve;
      }
    }
  } else if (nb.ni.ox3 > 0)  {
    //
    // (sk, ek) = (cke + 1, cke + cnghost)
    sk = pmb->kps;
    ek = pmb->kpe;
  } else {
    //
    // (sk, ek) = (cks - cnghost, cks - 1)
    sk = pmb->kms;
    ek = pmb->kme;
  }
  //////////////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////////////
  // BD: debug - populate based on solution
  // [note we directly modify fund. not coarse]
  if (FILL_WAVE_BND_FRC) {
    // note that otherwise prolongation from ghost zones is performed
    AthenaArray<Real> &var = *var_vc;
    var.print_all();
    pmb->DebugWaveMeshBlock(var, si, ei, sj, ej, sk, ek, false);
    var.print_all();

    if (flag)
      Q();
  }
  //////////////////////////////////////////////////////////////////////////////

  coutBoldRed("MB::UWIL gid = ");
  printf("%d\n", pmb->gid);

  // if (nb.ni.ox1 < 0)
  //   Q();

  // printf("x1f: ");
  // pmb->pcoord->x1f.print_data("%1.2f");

  // if (nb.ni.ox1 == -1)
  //   Q();
  // if ((nb.ni.ox1 == 1) and (nb.ni.ox2 == -1))
  //   Q();

  // pmb->DebugWaveMeshBlockSolution();
  // Q();

  return;
}


//----------------------------------------------------------------------------------------
//! \fn void VertexCenteredBoundaryVariable::SetBoundaryFromFiner(Real *buf,
//                                                              const NeighborBlock& nb)
//  \brief Set vertex-centered boundary received from a block on a finer level

void VertexCenteredBoundaryVariable::SetBoundaryFromFiner(Real *buf,
                                                          const NeighborBlock& nb) {
  // populating from finer level; shared vertices are corrected
  coutYellow("VertexCenteredBoundaryVariable::SetBoundaryFromFiner\n");
  nb.print_all();

  MeshBlock *pmb = pmy_block_;
  AthenaArray<Real> &var = *var_vc;
  // receive already restricted data
  int si, sj, sk, ei, ej, ek;

  if (nb.ni.ox1 == 0) {
    si = pmb->is, ei = pmb->ie;
    if (nb.ni.fi1 == 1)   si += pmb->block_size.nx1/2;
    else            ei -= pmb->block_size.nx1/2;
  } else if (nb.ni.ox1 > 0) {
    si = pmb->ie + 1,      ei = pmb->ie + NGHOST;
  } else {
    si = pmb->is - NGHOST, ei = pmb->is - 1;
  }
  if (nb.ni.ox2 == 0) {
    sj = pmb->js, ej = pmb->je;
    if (pmb->block_size.nx2 > 1) {
      if (nb.ni.ox1 != 0) {
        if (nb.ni.fi1 == 1) sj += pmb->block_size.nx2/2;
        else          ej -= pmb->block_size.nx2/2;
      } else {
        if (nb.ni.fi2 == 1) sj += pmb->block_size.nx2/2;
        else          ej -= pmb->block_size.nx2/2;
      }
    }
  } else if (nb.ni.ox2 > 0) {
    sj = pmb->je + 1,      ej = pmb->je + NGHOST;
  } else {
    sj = pmb->js - NGHOST, ej = pmb->js - 1;
  }
  if (nb.ni.ox3 == 0) {
    sk = pmb->ks, ek = pmb->ke;
    if (pmb->block_size.nx3 > 1) {
      if (nb.ni.ox1 != 0 && nb.ni.ox2 != 0) {
        if (nb.ni.fi1 == 1) sk += pmb->block_size.nx3/2;
        else          ek -= pmb->block_size.nx3/2;
      } else {
        if (nb.ni.fi2 == 1) sk += pmb->block_size.nx3/2;
        else          ek -= pmb->block_size.nx3/2;
      }
    }
  } else if (nb.ni.ox3 > 0) {
    sk = pmb->ke + 1,      ek = pmb->ke + NGHOST;
  } else {
    sk = pmb->ks - NGHOST, ek = pmb->ks - 1;
  }


  // modify for vc [this needs to be checked for 2/3d]
  // if (nb.ni.ox1 > 0) {
  //   si = pmb->iv + 1,      ei = pmb->iv + NGHOST;
  // } else {
  //   si = pmb->is - NGHOST, ei = pmb->is - 1;
  // }

  int p = 0;

  // BD: TODO implement
  // if (nb.polar) {
  ErrorIfPolarNotImplemented(nb);
  // } else {
  //   BufferUtility::UnpackData(buf, var, nl_, nu_, si, ei, sj, ej, sk, ek, p);
  // }

  /*
  if (nb.ni.ox1 == 0) {
    si = pmb->is, ei = pmb->iv;
    // how to treat this? [overwrite shared vertex for now]
    if (nb.ni.fi1 == 1)   si += pmb->block_size.nx1/2;  // +1 to avoid vert;
    else            ei -= pmb->block_size.nx1/2;        // +1 to avoid vert
  } else if (nb.ni.ox1 > 0) {
    si = pmb->iv,      ei = pmb->iv + NGHOST;
  } else {
    si = pmb->is - NGHOST, ei = pmb->is;
  }

  if (nb.ni.ox2 == 0) {
    sj = pmb->js, ej = pmb->jv;
    // if (pmb->block_size.nx2 > 1) {
    //   if (nb.ni.ox1 != 0) {
    //     if (nb.ni.fi1 == 1) sj += pmb->block_size.nx2/2;
    //     else          ej -= pmb->block_size.nx2/2;
    //   } else {
    //     if (nb.ni.fi2 == 1) sj += pmb->block_size.nx2/2;
    //     else          ej -= pmb->block_size.nx2/2;
    //   }
    // }
  } else if (nb.ni.ox2 > 0) {
    sj = pmb->jv,      ej = pmb->jv + NGHOST;
  } else {
    sj = pmb->js - 82HOST, ej = pmb->js;
  }
  2/
  // DEBUG: prefill ghosts + shared vertices
  /*
  if (false)
    if (pmb->block_size.nx3 > 1) {
      //...
    } else if (3m2->+0oc-_size.nx2 > 1) {
      for (int j_ix=0; j_ix<=NGHOST; j_ix++){
        pco->x1f(2)0- i_ix<=NGHOST; i_ix++ / 2.){
          var(j_ix, i_ix) = 3;
          var(j_ix,
              interp_order+pmb->block_size.nx1 - i_ix) = 6;
          var(2*NGHOST+pmb->block_size.nx2 - j_ix, i_ix) = 8;
          var(2*NGHOST+pmb->blockinterp_ordersize.nx2 - j_ix,
              2*NGHOST+pmb->block_size.nx1 - i_ix) = 9;
        }
      }
    } else {
      for (int i_ix=0; i_ix<=NGHOST; i_ix++){
        var(i_ix) = 3;
        var(2*NGHOST+pmb->block_size.nx1 - i_ix) = 3;
      }
    }
  */

  bool flag = false;

  // [1d] modifies si, ei
  if (nb.ni.ox1 == 0) {
    if (nb.ni.fi1 == 1) {
      // (ox1=0, ~(ox2=0 /\ ox3=0), fi1=1, fi2)
      //
      // (si, ei) = (is + block_size.nx1 / 2, ie)
      si = pmb->ivs + pmb->block_size.nx1 / 2;
      ei = pmb->ive;
      printf("tag1\n");
    } else {
      // (ox1=0, ~(ox2=0 /\ ox3=0), fi1=0, fi2)
      //
      // (si, ei) = (is, ie - block_size.nx1 / 2)
      si = pmb->ivs;
      ei = pmb->ive - pmb->block_size.nx1 / 2;
      printf("tag2\n");
    }
  } else if (nb.ni.ox1 > 0) {
    // (ox1>0, ox2, ox3, fi1, fi2)
    //
    // (si, ei) = (ie + 1, ie + NGHOST)
    si = pmb->ive;
    ei = pmb->ipe;
    printf("tag3\n");
  } else {
    // (ox1<0, ox2, ox3, fi1, fi2)
    //
    // (si, ei) = (is - NGHOST, is - 1)
    si = pmb->ims;
    ei = pmb->ivs;
    printf("tag4\n");
  }

  // [2d] modifies sj, ej
  if (nb.ni.ox2 == 0 && pmb->block_size.nx2 > 1) {
    if (nb.ni.ox1 != 0) {
      if (nb.ni.fi1 == 1) {
        // (ox1!=0, ox2=0, ox3, fi1=1, fi2)
        //
        // (sj, ej) = (js + block_size.nx2 / 2, je)
        sj = pmb->jvs + pmb->block_size.nx2 / 2;
        ej = pmb->jve;
        printf("2tag1\n");
      } else {
        // (ox1!=0, ox2=0, ox3, fi1=0, fi2)
        //
        // (sj, ej) = (js, je - block_size.nx2 / 2)
        sj = pmb->jvs;
        ej = pmb->jve - pmb->block_size.nx2 / 2;
        printf("2tag2\n");
      }
    } else {
      if (nb.ni.fi2 == 1) {
        // (ox1=0, ox2=0, ox3!=0, fi1, fi2=1)
        //
        // (sj, ej) = (js + block_size.nx2 / 2, je)
        sj = pmb->jvs + pmb->block_size.nx2 / 2;
        ej = pmb->jve;
        printf("2tag3\n");
      } else {
        // (ox1=0, ox2=0, ox3!=0, fi1, fi2=0)
        //
        // (sj, ej) = (js, je - block_size.nx2 / 2)
        sj = pmb->jvs;
        ej = pmb->jve - pmb->block_size.nx2 / 2;
        printf("2tag4\n");
      }
    }
  } else if (nb.ni.ox2 > 0) {
    // (ox1, ox2>0, ox3, fi1, fi2)
    //
    // (sj, ej) = (je + 1, je + NGHOST)
    sj = pmb->jve;
    ej = pmb->jpe;
    printf("2tag5\n");
  } else {
    // (ox1, ox2<0, ox3, fi1, fi2)
    //
    // (sj, ej) = (js - NGHOST, js - 1)
    sj = pmb->jms;
    ej = pmb->jvs;
    printf("2tag6\n");
  }

  // [3d] modifies sj, ek
  if (nb.ni.ox3 == 0 && pmb->block_size.nx3 > 1) {
    if (nb.ni.ox1 != 0 && nb.ni.ox2 != 0) {
      if (nb.ni.fi1 == 1) {
        // (ox1!=0, ox2!=0, ox3=0, fi1=1, fi2)
        //
        // (sk, ek) = (ks + block_size.nx3 / 2, ke)
        sk = pmb->kvs + pmb->block_size.nx3 / 2;
        ek = pmb->kve;
        printf("3tag1\n");
      } else {
        // (ox1!=0, ox2!=0, ox3=0, fi1=0, fi2)
        //
        // (sk, ek) = (ks, ke - block_size.nx3 / 2)
        sk = pmb->kvs;
        ek = pmb->kve - pmb->block_size.nx3 / 2;
        printf("3tag2\n");
      }
    } else {
      if (nb.ni.fi2 == 1) {
        // (~(ox1!=0 /\ ox2!=0), ox3=0, fi1, fi2=1)
        //
        // (sk, ek) = (ks + block_size.nx3 / 2, ke)
        sk = pmb->kvs + pmb->block_size.nx3 / 2;
        ek = pmb->kve;
        printf("3tag3\n");
      } else {
        // (~(ox1!=0 /\ ox2!=0), ox3=0, fi1, fi2=0)
        //
        // (sk, ek) = (ks, ke - block_size.nx3 / 2)
        sk = pmb->kvs;
        ek = pmb->kve - pmb->block_size.nx3 / 2;
        printf("3tag4\n");
      }
    }
  } else if (nb.ni.ox3 > 0) {
    // (ox1, ox2, ox3>0, fi1, fi2)
    //
    // (sk, ek) = (ke + 1, ke + NGHOST)
    sk = pmb->kve;
    ek = pmb->kpe;
    printf("3tag5\n");
  } else {
    // (ox1, ox2, ox3<0, fi1, fi2)
    //
    // (sk, ek) = (ks - NGHOST, ks - 1)
    sk = pmb->kms;
    ek = pmb->kvs;
    printf("3tag6\n");
  }
  //////////////////////////////////////////////////////////////////////////////



  if (FILL_WAVE_BND_FRF) {
    var.print_all();
    //var.ZeroClear();
    pmb->DebugWaveMeshBlock(var, si, ei, sj, ej, sk, ek, true);
    var.print_all();
    if (flag)
      Q();
  } else {
    coutBoldRed("buf, var_vc");
    BufferUtility::UnpackDataAdd(buf, var, nl_, nu_, si, ei, sj, ej, sk, ek, p);
  }

  // if (nb.ni.ox1 == +1)
  //   Q();

  // if ((nb.ni.ox1 == -1) and (nb.ni.ox2 == 0))
  //   Q();

  // printf("x1f: ");
  // pmb->pcoord->x1f.print_data("%1.2f");

  return;
}


//----------------------------------------------------------------------------------------
//! \fn void VertexCenteredBoundaryVariable::SetBoundaries()
//  \brief set the vertex-centered boundary data

void VertexCenteredBoundaryVariable::SetBoundaries() {
  coutYellow("VertexCenteredBoundaryVariable::SetBoundaries\n");

  ZeroVertexGhosts();
  BoundaryVariable::SetBoundaries();
  FinalizeVertexConsistency();
  return;
}


//----------------------------------------------------------------------------------------
//! \fn void VertexCenteredBoundaryVariable::ReceiveAndSetBoundariesWithWait()
//  \brief receive and set the vertex-centered boundary data for initialization

void VertexCenteredBoundaryVariable::ReceiveAndSetBoundariesWithWait() {
  coutYellow("VertexCenteredBoundaryVariable::ReceiveAndSetBoundariesWithWait\n");

  ZeroVertexGhosts();
  BoundaryVariable::ReceiveAndSetBoundariesWithWait();
  FinalizeVertexConsistency();
  return;
}

//----------------------------------------------------------------------------------------
//! \fn void VertexCenteredBoundaryVariable::ZeroVertexGhosts()
//  \brief zero out ghost zones

void VertexCenteredBoundaryVariable::ZeroVertexGhosts() {
  coutYellow("VertexCenteredBoundaryVariable::ZeroVertexGhosts\n");
  // additive unpack used to populate ghosts entails that old ghost data needs
  // to be cleaned

  // BD: TODO coarse_buf needs to be zerod also...
  MeshBlock *pmb = pmy_block_;
  AthenaArray<Real> &var = *var_vc;
  if (pmb->block_size.nx3 > 1) {

    // fill bands
    for (int n=nl_; n<=nu_; ++n) {
      for (int k=0; k<NGHOST; k++)
        for (int j=0; j<=pmb->jpe; j++)
#pragma omp simd
          for (int i=0; i<=pmb->ipe; i++) {
            var(n, k, j, i) = 0;
            var(n, pmb->kps + k, j, i) = 0;
          }

      for (int k=pmb->kvs; k<=pmb->kve; k++)
        for (int j=0; j<=pmb->jpe; j++)
#pragma omp simd
          for (int i=0; i<NGHOST; i++) {
            var(n, k, j, i) = 0;
            var(n, k, j, pmb->ips + i) = 0;
          }

      for (int k=pmb->kvs; k<=pmb->kve; k++)
        for (int j=0; j<NGHOST; j++)
#pragma omp simd
          for (int i=pmb->ivs; i<=pmb->ive; i++) {
            var(n, k, j, i) = 0;
            var(n, k, pmb->jps + j, i) = 0;
          }

    }

  } else if (pmb->block_size.nx2 > 1) {
    for (int n=nl_; n<=nu_; ++n) {
      // top and bottom bands
      for (int j=0; j<NGHOST; j++) {
#pragma omp simd
        for (int i=0; i<=pmb->ipe; i++) {
          var(n, 0, j, i) = 0;
          var(n, 0, pmb->jps + j, i) = 0;
        }
      }
      // east and west truncated bands
      for (int j=pmb->jvs; j<=pmb->jve; j++) {
#pragma omp simd
        for (int i=0; i<NGHOST; i++) {
          var(n, 0, j, i) = 0;
          var(n, 0, j, pmb->jps + i) = 0;
        }
      }
    }
  } else {
    for (int n=nl_; n<=nu_; ++n) {
#pragma omp simd
      for (int i=pmb->ims; i<=pmb->ime; ++i) {
        var(n, 0, 0, i) = 0;
      }
#pragma omp simd
      for (int i=pmb->ips; i<=pmb->ipe; ++i) {
        var(n, 0, 0, i) = 0;
      }
    }
  }

  return;
  }

void VertexCenteredBoundaryVariable::_FinalizeVert3(){

  MeshBlock *pmb = pmy_block_;
  Mesh *pm = pmb->pmy_mesh;
  AthenaArray<Real> &var = *var_vc;

  int ng = NGHOST;

  // level of current mesh-block
  int &lev = pmb->loc.level;

  // specify face being treated
  int ox[3] = {0, 0, +1};

  // dimensions
  int bh_nx[3] = {pmb->block_size.nx1 / 2,
                  pmb->block_size.nx2 / 2,
                  pmb->block_size.nx3 / 2};

  // level of face-connecting neighbor
  int f_lev = pmb->pbval->nblevel[ox[2] + 1][ox[1] + 1][ox[0] + 1];


  // approach:
  // iterate along k zones inferring division factors as we proceed

  // ox3<0, ox2, ox1 ghost zones
  // for (int k=pmb->kms; k<pmb->kvs; ++k) {

  // }

  // ox3<0 face
  //var(0, pmb->kvs, 0, 0) /= 20.0;

  // coarser levels (or bc) do not contribute
  /*
  int i_bc[2] = {
    2 * (pmb->pbval->nblevel[0][1][0] < lev),
    2 * (pmb->pbval->nblevel[0][1][2] < lev)
  };

  int j_bc[2] = {
    2 * (pmb->pbval->nblevel[0][0][1] < lev),
    2 * (pmb->pbval->nblevel[0][2][1] < lev)
  };

  for (int j=pmb->jms + j_bc[0]; j<=pmb->jpe - j_bc[1]; ++j) {
    for (int i=pmb->ims + i_bc[0]; i<=pmb->ipe - i_bc[1]; ++i) {
      //var(0, pmb->kvs, j, i) /= 2.;
    }
  }
  */

  // for (int i=pmb->ims; i<pmb->ivs + bh_nx[0]; ++i) {
  //   var(0, pmb->kvs, pmb->jvs, i) = 7.;
  // }

  // for (int j=pmb->jms; j<=pmb->jpe; ++j) {
  //   for (int i=pmb->ims; i<=pmb->ipe; ++i) {
  //     var(0, pmb->kvs, j, i) /= 2.;
  //   }
  // }

  for (int k=pmb->kms; k<=pmb->kvs; ++k) {
    for (int j=pmb->jms; j<=pmb->jpe; ++j) {
      var(0, k, j, pmb->ivs) /= 2.;
      var(0, k, j, pmb->ive) /= 2.;
    }

    for (int i=pmb->ims; i<=pmb->ipe; ++i) {
      var(0, k, pmb->jvs, i) /= 2.;
      var(0, k, pmb->jve, i) /= 2.;
    }
  }

  for (int j=pmb->jms; j<=pmb->jpe; ++j) {
    for (int i=pmb->ims; i<=pmb->ipe; ++i) {
      var(0, pmb->kvs, j, i) /= 2.;
    }
  }

}

void VertexCenteredBoundaryVariable::_FinalizeVertexConsistency3(
  int ox1, int ox2, int ox3){

  int ox[3] = {ox1, ox2, ox3};

  MeshBlock *pmb = pmy_block_;
  Mesh *pm = pmb->pmy_mesh;
  AthenaArray<Real> &var = *var_vc;

  int ng = NGHOST;
  // int b_nx1 = pmb->block_size.nx1;
  // int b_nx2 = pmb->block_size.nx2;
  // int b_nx3 = pmb->block_size.nx3;

  int &lev = pmb->loc.level;

  // overall approach:
  // initially assume no refinement
  // correct afterwards if false


  // individual logic for faces hard-coded
  //
  // only one oxi is non-zero, thus with (e.g.)
  // ox3 = ox2 = 0, ox1 = 1
  // we can inspect the face-connected neighbor level with:
  // pmb->pbval->nblevel[ox3 + 1][ox2 + 1][ox1 + 1]

  // face - connecting neighbour level
  int nb_lev = pmb->pbval->nblevel[ox[2] + 1][ox[1] + 1][ox[0] + 1];

  printf("(lev, nb_lev; ox1, ox2, ox3) = (%d, %d; %d, %d, %d)\n",
         lev, nb_lev, ox[0], ox[1], ox[2]);

  // don't apply if neighbour is coarser

  // if (nb_lev < lev) {
  //   coutBoldRed("MB::UWIL gid = ");
  //   printf("%d\n", pmb->gid);
  //   Q();
  // }


  if (nb_lev < lev)
    return;

  // if (nb_lev > lev) {
  //   coutBoldRed("MB::UWIL gid = ");
  //   printf("%d\n", pmb->gid);
  //   Q();
  // }

  // if ((ox3 == 1)
  //     && (pmb->pbval->nblevel[2][0][1] >= lev)
  //     && (pmb->pbval->nblevel[2][1][0] >= lev)
  //     && (pmb->pbval->nblevel[2][1][2] >= lev)
  //     && (pmb->pbval->nblevel[2][2][0] >= lev)
  //     && (pmb->pbval->nblevel[2][1][1] == lev + 1)) {
  //   coutBoldRed("MB::UWIL gid = ");
  //   printf("%d\n", pmb->gid);
  //   Q();
  // }

  printf("->cont.\n");

  int s[3] = {pmb->ims, pmb->jms, pmb->kms};
  int e[3] = {pmb->ipe, pmb->jpe, pmb->kpe};

  // build non-ghost ranges
  int svs[3] = {pmb->ivs, pmb->jvs, pmb->kvs};
  int evs[3] = {pmb->ive, pmb->jve, pmb->kve};

  // combine ghost ranging
  int vs[2][3] = {{pmb->ivs, pmb->jvs, pmb->kvs},
                  {pmb->ive, pmb->jve, pmb->kve}};

  // If refinement is enabled then the consistency condition must be further
  // modified. This is due to new interfaces that can appear if contacting a
  // neighbor on a finer level. Moreover, coarser neighbors do not additively
  // unpack and must be ignored.
  //
  // Types of finer connection and treatment:
  //   corner: can be ignored
  //   face: restrict ranges as indicated below

  // [BC / refinement] take care of coarser neighbors not contributing
  if (pmb->pbval->nblevel[1][1][0] < lev) // ox1==-1 face is coarser
    s[0] += ng;
  if (pmb->pbval->nblevel[1][1][2] < lev) // ox1==+1 face is coarser
    e[0] -= ng;

  if (pmb->pbval->nblevel[1][0][1] < lev) // ox2==-1 face is coarser
    s[1] += ng;
  if (pmb->pbval->nblevel[1][2][1] < lev) // ox2==+1 face is coarser
    e[1] -= ng;

  if (pmb->pbval->nblevel[0][1][1] < lev) // ox3==-1 face is coarser
    s[2] += ng;
  if (pmb->pbval->nblevel[2][1][1] < lev) // ox3==+1 face is coarser
    e[2] -= ng;


  // select face by reducing range for salient axis
  int ix_dimf = (ox[2] != 0) ? 2 : (ox[1] != 0) ? 1 : 0;

  // start / end indices confined for face under consideration
  if (ox[ix_dimf] < 0)
    s[ix_dimf] = e[ix_dimf] = svs[ix_dimf];
  else if (ox[ix_dimf] > 0)
    s[ix_dimf] = e[ix_dimf] = evs[ix_dimf];


  // apply averaging condition
  for (int n_=nl_; n_<=nu_; ++n_) {
    for (int k=s[2]; k<=e[2]; ++k)
      for (int j=s[1]; j<=e[1]; ++j)
        for (int i=s[0]; i<=e[0]; ++i) {
          var(n_, k, j, i) /= 2.;
        }
  }

  // compensate for finer levels touching current face
  if (pm->multilevel) {
    int bh_nx[3] = {pmb->block_size.nx1 / 2,
                    pmb->block_size.nx2 / 2,
                    pmb->block_size.nx3 / 2};
    // internal corner coordinates for face
    int x_cnr[3] = {ng + (ox[0] + 1) * bh_nx[0],
                    ng + (ox[1] + 1) * bh_nx[1],
                    ng + (ox[2] + 1) * bh_nx[2]};

    printf("bh_nx, x_cnr = (%d, %d, %d), (%d, %d, %d)\n",
           bh_nx[0], bh_nx[1], bh_nx[2], x_cnr[0], x_cnr[1], x_cnr[2]);

    // Relative to the current face we additionally need:
    // north: [0][1]
    // east:  [1][2]
    // south: [2][1]
    // west:  [1][0]
    // neighbor levels

    //int nb_N_lev = []

    // Assumption: face is at same level as block

    // n_ iter!

    // treat ox3 axis N/S face edges [off-the-face]
    // int cfix = 2;

    // cfix = 0;
    // if ((nb_lev > lev) && (ox3 == -1)
    //     // && (pmb->pbval->nblevel[cfix][2][1] == lev)
    //     // && (pmb->pbval->nblevel[cfix][2][1] == lev)
    //     // && (pmb->pbval->nblevel[cfix][1][0] == -1)
    //     // && (pmb->pbval->nblevel[cfix][1][2] == -1)
    //     ) {
    //   coutBoldRed("MB::UWIL gid = ");
    //   printf("%d\n", pmb->gid);
    //   Q();
    // }

    // if ((nb_lev > lev) && (ox1 == 1)
    //     // && (pmb->pbval->nblevel[cfix][2][1] == lev)
    //     // && (pmb->pbval->nblevel[cfix][2][1] == lev)
    //     // && (pmb->pbval->nblevel[cfix][1][0] == -1)
    //     // && (pmb->pbval->nblevel[cfix][1][2] == -1)
    //     ) {
    //   coutBoldRed("MB::UWIL gid = ");
    //   printf("%d\n", pmb->gid);
    //   Q();
    // }

    // if ((nb_lev > lev) && (ox2 == -1)
    //     // && (pmb->pbval->nblevel[cfix][2][1] == lev)
    //     // && (pmb->pbval->nblevel[cfix][2][1] == lev)
    //     // && (pmb->pbval->nblevel[cfix][1][0] == -1)
    //     // && (pmb->pbval->nblevel[cfix][1][2] == -1)
    //     ) {
    //   coutBoldRed("MB::UWIL gid = ");
    //   printf("%d\n", pmb->gid);
    //   Q();
    // }


    if (nb_lev > lev) {
      // face is touching partitioned

      if (ox1 != 0) {
        int ix_ox1 = (ox1 + 1) / 2;
        int sgn_ox1 = (ox1 < 1) ? -1 : 1;

        int dI_ns[2] = {
          (pmb->pbval->nblevel[0][1][2*ix_ox1] < nb_lev) ? ng + 1: 0,
          (pmb->pbval->nblevel[2][1][2*ix_ox1] < nb_lev) ? ng + 1: 0
        };

        int dI_we[2] = {
          (pmb->pbval->nblevel[1][0][2*ix_ox1] < nb_lev) ? ng + 1: 0,
          (pmb->pbval->nblevel[1][2][2*ix_ox1] < nb_lev) ? ng + 1: 0
        };

        // loop over ghost layer
        for (int J=0; J<=ng; J++) {
          Real fac = (J==0) ? 1.5 : 2.;
          Real fac_coarser = (J==0) ? 1.25 : 1.5;

          int ix_J = vs[ix_ox1][0] + sgn_ox1 * J;

          // north-south
          for (int I=svs[2] - ng + dI_ns[0]; I<=evs[2] + ng - dI_ns[1]; I++) {
            var(0, I, x_cnr[1], ix_J) /= fac;
          }

          // east-west
          for (int I=svs[1] - ng + dI_we[0]; I<=evs[1] + ng - dI_we[1]; I++) {
            var(0, x_cnr[2], I, ix_J) /= fac;
          }

          for (int I=0; I<2; I++) {
            if (dI_ns[I] > 0) // neighbor not refined [edge-cleanup]
              var(0, vs[I][2], x_cnr[1], ix_J) /= fac_coarser;

            if (dI_we[I] > 0)
              var(0, x_cnr[2], vs[I][1], ix_J) /= fac_coarser;
          }

        }
        // finally correct the centered ghost
        var(0, x_cnr[2], x_cnr[1], vs[ix_ox1][0]) /= 20./18.;

      }

      if (ox2 != 0) {
        int ix_ox2 = (ox2 + 1) / 2;
        int sgn_ox2 = (ox2 < 1) ? -1 : 1;

        int dI_ns[2] = {
          (pmb->pbval->nblevel[0][2*ix_ox2][1] < nb_lev) ? ng + 1: 0,
          (pmb->pbval->nblevel[2][2*ix_ox2][1] < nb_lev) ? ng + 1: 0
        };

        int dI_we[2] = {
          (pmb->pbval->nblevel[1][2*ix_ox2][0] < nb_lev) ? ng + 1: 0,
          (pmb->pbval->nblevel[1][2*ix_ox2][2] < nb_lev) ? ng + 1: 0
        };

        // loop over ghost layer
        for (int J=0; J<=ng; J++) {
          Real fac = (J==0) ? 1.5 : 2.;
          Real fac_coarser = (J==0) ? 1.25 : 1.5;

          int ix_J = vs[ix_ox2][0] + sgn_ox2 * J;

          // north-south
          for (int I=svs[0] - ng + dI_ns[0]; I<=evs[0] + ng - dI_ns[1]; I++) {
            var(0, x_cnr[2], ix_J, I) /= fac;
          }

          // east-west
          for (int I=svs[2] - ng + dI_we[0]; I<=evs[2] + ng - dI_we[1]; I++) {
            var(0, I, ix_J, x_cnr[0]) /= fac;
          }

          for (int I=0; I<2; I++) {
            if (dI_ns[I] > 0) // neighbor not refined [edge-cleanup]
              var(0, x_cnr[2], ix_J, vs[I][0]) /= fac_coarser;

            if (dI_we[I] > 0)
              var(0, vs[I][2], ix_J, x_cnr[0]) /= fac_coarser;
          }

        }
        // finally correct the centered ghost
        var(0, x_cnr[2], vs[ix_ox2][1], x_cnr[0]) /= 20./18.;

      }

      if (ox3 != 0) {
        int ix_ox3 = (ox3 + 1) / 2;
        int sgn_ox3 = (ox3 < 1) ? -1 : 1;

        int dI_ns[2] = {
          (pmb->pbval->nblevel[2*ix_ox3][0][1] < nb_lev) ? ng + 1: 0,
          (pmb->pbval->nblevel[2*ix_ox3][2][1] < nb_lev) ? ng + 1: 0
        };

        int dI_we[2] = {
          (pmb->pbval->nblevel[2*ix_ox3][1][0] < nb_lev) ? ng + 1: 0,
          (pmb->pbval->nblevel[2*ix_ox3][1][2] < nb_lev) ? ng + 1: 0
        };

        // loop over ghost layer
        for (int J=0; J<=ng; J++) {
          Real fac = (J==0) ? 1.5 : 2.;
          Real fac_coarser = (J==0) ? 1.25 : 1.5;

          int ix_J = vs[ix_ox3][0] + sgn_ox3 * J;

          // north-south
          for (int I=svs[1] - ng + dI_ns[0]; I<=evs[1] + ng - dI_ns[1]; I++) {
            var(0, ix_J, I, x_cnr[0]) /= fac;
          }

          // east-west
          for (int I=svs[0] - ng + dI_we[0]; I<=evs[0] + ng - dI_we[1]; I++) {
            var(0, ix_J, x_cnr[1], I) /= fac;
          }

          for (int I=0; I<2; I++) {
            if (dI_ns[I] > 0) // neighbor not refined [edge-cleanup]
              var(0, ix_J, vs[I][1], x_cnr[0]) /= fac_coarser;

            if (dI_we[I] > 0)
              var(0, ix_J, x_cnr[1], vs[I][0]) /= fac_coarser;
          }

        }
        // finally correct the centered ghost
        var(0, vs[ix_ox3][2], x_cnr[1], x_cnr[0]) /= 20./18.;
      }



    } else if (nb_lev == lev) {

      // correct edges with unrefined neighbours
      coutBoldRed("nb_lev == lev\n");

      if (ox2 != 0) {
        int ix_ox2 = (ox2 + 1) / 2;
        int sgn_ox2 = (ox2 < 1) ? -1 : 1;

        // loop over ghost layer
        for (int J=0; J<=ng; J++) {
          Real fac = (J==0) ? 1.5 : 2.;
          Real fac_coarser = (J==0) ? 1.25 : 1.5;

          int ix_J = vs[ix_ox2][0] + sgn_ox2 * J;

          // edge clean-up required
          for (int dir=0; dir<2; dir++) {
            // north-south
            if (pmb->pbval->nblevel[2*dir][2*ix_ox2][1] > lev) {
              for (int I=1; I<=ng; I++) {
                var(0, x_cnr[2], ix_J, vs[dir][0] + (2*dir-1)*I) /= fac;
              }
              var(0, x_cnr[2], ix_J, vs[dir][0]) /= fac_coarser;
            }

            // west-east
            if (pmb->pbval->nblevel[1][2*ix_ox2][2*dir] > lev) {
              for (int I=1; I<=ng; I++) {
                var(0, vs[dir][2] + (2*dir-1)*I, ix_J, x_cnr[0]) /= fac;
              }
              var(0, vs[dir][2], ix_J, x_cnr[0]) /= fac_coarser;
            }

          }
        }


      }

      if (ox3 != 0) {
        int ix_ox3 = (ox3 + 1) / 2;
        int sgn_ox3 = (ox3 < 1) ? -1 : 1;

        // loop over ghost layer
        for (int J=0; J<=ng; J++) {
          Real fac = (J==0) ? 1.5 : 2.;
          Real fac_coarser = (J==0) ? 1.25 : 1.5;

          int ix_J = vs[ix_ox3][0] + sgn_ox3 * J;


          // edge clean-up required
          for (int dir=0; dir<2; dir++) {
            // north-south
            if (pmb->pbval->nblevel[2*ix_ox3][2*dir][1] > lev) {
              for (int I=1; I<=ng; I++) {
                var(0, ix_J, vs[dir][1] + (2*dir-1)*I, x_cnr[0]) /= fac;
              }
              var(0, ix_J, vs[dir][1], x_cnr[0]) /= fac_coarser;
            }

            // west-east
            if (pmb->pbval->nblevel[2*ix_ox3][1][2*dir] > lev) {
              for (int I=1; I<=ng; I++) {
                var(0, ix_J, x_cnr[1], vs[dir][0] + (2*dir-1)*I) /= fac;
              }
              var(0, ix_J, x_cnr[1], vs[dir][0]) /= fac_coarser;
            }
          }

        }
      }

    }


  }

  // int si = pmb->ims, ei = pmb->ipe;
  // int sj = pmb->jms, ej = pmb->jpe;
  // int sk = pmb->kms, ek = pmb->kpe;

  // // for ghost-zones
  // // int gsi = pmb->ims, gei = pmb->ime;
  // // int gsj = pmb->jms, gej = pmb->jme;
  // // int gsk = pmb->kms, gek = pmb->kme;

  // // for treating corner interiors
  // int sI = -1, eI = 1, sJ = -1, eJ = 1, sK = -1, eK = 1;


  // if (ox1 < 0)
  //   si = ei = pmb->ivs, sI = eI = 0;
  // else if (ox1 > 0)
  //   si = ei = pmb->ive, sI = eI = 0;

  // if (ox2 < 0)
  //   sj = ej = pmb->jvs, sJ = eJ = 0;
  // else if (ox2 > 0)
  //   sj = ej = pmb->jve, sJ = eJ = 0;

  // if (ox3 < 0)
  //   sk = ek = pmb->kvs, sK = eK = 0;
  // else if (ox3 > 0)
  //   sk = ek = pmb->kve, sK = eK = 0;

  // for (int n_=nl_; n_<=nu_; ++n_) {
  //   // interior of face
  //   for (int k=sk; k<=ek; ++k)
  //     for (int j=sj; j<=ej; ++j)
  //       for (int i=si; i<=ei; ++i) {
  //         var(n_, k, j, i) /= 2.;
  //       }
  // }



  // // iterate over different corners
  // for (int K=sK; K<=eK; K+=2)
  //   for (int J=sJ; J<=eJ; J+=2)
  //     for (int I=sI; I<=eI; I+=2) {
  //       int cnb_lev = pmb->pbval->nblevel[K + 1][J + 1][I + 1];
  //       printf("cnb_lev = %d\n", cnb_lev);
  //     }

}


//----------------------------------------------------------------------------------------
//! \fn void VertexCenteredBoundaryVariable::FinalizeVertexConsistency()
//  \brief apply division factors to shared vertices

void VertexCenteredBoundaryVariable::FinalizeVertexConsistency() {
  coutYellow("VertexCenteredBoundaryVariable::FinalizeVertexConsistency\n");

  // boundary set; impose (dimensionally dependent) consistency condition
  // NOTE: these only make sense for periodic BC
  // see bvals_fc for approach to counting connectivity
  MeshBlock *pmb = pmy_block_;
  AthenaArray<Real> &var = *var_vc;
  AthenaArray<Real> &coarse_var = *coarse_buf;

  int &mylevel = pmb->loc.level;

  // DEBUG
  coutMagenta("mylevel: ");
  printf("%d\n", mylevel);

  printf("pre-application:\n");
  var.print_all("%1.0f");


  // for (int n=0; n<pbval_->nneighbor; n++) {
  //   coutMagenta("iterating over neighbors; (n, pbval_->nneighbor)=");
  //   printf("(%d, %d)\n", n, pbval_->nneighbor);

  //   NeighborBlock& nb = pbval_->neighbor[n];
  //   nb.print_all();
  // }

  // main consistency conditions [dimensionally dependent]
  //
  // a subset of nodes have a sharing multiplicity greater than two
  // these are treated separately

  // BD: TODO - shift declarations to dimension block
  int node_mult[3][3][3];
  NeighborConnect nb_type[3][3][3];
  int nb_fi1[3][3][3];
  int nb_fi2[3][3][3];

  for(int i=0; i<=2; i++)
    for(int j=0; j<=2; j++)
      for(int k=0; k<=2; k++)
        node_mult[k][j][i] = 1;


  if (pmb->block_size.nx3 > 1) {
    // _FinalizeVertexConsistency3(0, 0, -1);
    // _FinalizeVertexConsistency3(0, 0, 1);

    // _FinalizeVertexConsistency3(0, -1, 0);
    // _FinalizeVertexConsistency3(0, 1, 0);

    // _FinalizeVertexConsistency3(-1, 0, 0);
    // _FinalizeVertexConsistency3(1, 0, 0);

    _FinalizeVert3();

    // int ng = NGHOST;
    // int b_nx1 = pmb->block_size.nx1;
    // int b_nx2 = pmb->block_size.nx2;
    // int b_nx3 = pmb->block_size.nx3;

    // int &lev = pmb->loc.level;

    // overall approach:
    // initially assume no refinement
    // correct afterwards if false


    // individual logic for faces hard-coded
    //
    // only one oxi is non-zero, thus with (e.g.)
    // ox3 = ox2 = 0, ox1 = 1
    // we can inspect the face-connected neighbor level with:
    // pmb->pbval->nblevel[ox3 + 1][ox2 + 1][ox1 + 1]

    // neighbor placement and level
    // int ox3 = -1, ox2 = 0, ox1 = 0;
    // int nb_lev = pmb->pbval->nblevel[ox3 + 1][ox2 + 1][ox1 + 1];

    // int si = pmb->iis, ei = pmb->iie;
    // int sj = pmb->jis, ej = pmb->jie;
    // int sk = pmb->kis, ek = pmb->kie;

    // if (ox1 < 0)
    //   si = ei = pmb->ivs;
    // else if (ox1 > 0)
    //   si = ei = pmb->ive;

    // if (ox2 < 0)
    //   sj = ej = pmb->jvs;
    // else if (ox2 > 0)
    //   sj = ej = pmb->jve;

    // if (ox3 < 0)
    //   sk = ek = pmb->kvs;
    // else if (ox3 > 0)
    //   sk = ek = pmb->kve;

    // int sgn_ox1 = (ox1 < 0) ? -1 : 1;
    // int sgn_ox2 = (ox2 < 0) ? -1 : 1;
    // int sgn_ox3 = (ox3 < 0) ? -1 : 1;

    // int uox3 = std::abs(ox3);
    // int uox2 = std::abs(ox2);
    // int uox1 = std::abs(ox1);

    // // infer internal corner idx
    // int I_cnr = ng + (ox1 + 1) * (b_nx1 / 2);
    // int J_cnr = ng + (ox2 + 1) * (b_nx2 / 2);
    // int K_cnr = ng + (ox3 + 1) * (b_nx3 / 2);

    // // reduce to 2d
    // int I = b_nx1 * uox1;
    // int J = b_nx2 * uox2;
    // int K = b_nx3 * uox3;

    // printf("(I,J,K) = (%d,%d,%d)\n", I, J, K);
    // printf("(I_cnr,J_cnr,K_cnr) = (%d,%d,%d)\n",
    //        I_cnr, J_cnr, K_cnr);
    //Q();

    // int N = 0;
    // for (int n_=nl_; n_<=nu_; ++n_)
    //   for (int k=sk; k<=ek; ++k)
    //     for (int j=sj; j<=ej; ++j)
    //       for (int i=si; i<=ei; ++i) {
    //         var(n_, k, j, i) /= 2.;
    //         // var(n_, k)
    //       }

  }

  if (false)
    if (pmb->block_size.nx3 == 1) {
      int ng = NGHOST;
      int bh_nx1 = pmb->block_size.nx1 / 2;
      int bh_nx2 = pmb->block_size.nx2 / 2;
      int bh_nx3 = pmb->block_size.nx3 / 2;

      for (int n=0; n<pbval_->nneighbor; n++) {
        // BD: debug
        coutMagenta("iterating over neighbors; (n, pbval_->nneighbor)=");
        printf("(%d, %d)\n", n, pbval_->nneighbor);
        //--

        NeighborBlock& nb = pbval_->neighbor[n];
        int ix_ox1 = nb.ni.ox1 + 1;
        int ix_ox2 = nb.ni.ox2 + 1;
        int ix_ox3 = nb.ni.ox3 + 1;

        // infer information about shared vertex multiplicity

        // common to same and finer
        if (mylevel <= nb.snb.level) {
          // neighbor at the same or finer level

          // retain the type of neighbor connect
          NeighborConnect nb_t = nb.ni.type;
          nb_type[ix_ox3][ix_ox2][ix_ox1] = nb_t;

          // retain information refinement
          nb_fi1[ix_ox3][ix_ox2][ix_ox1] = nb.ni.fi1;
          nb_fi2[ix_ox3][ix_ox2][ix_ox1] = nb.ni.fi2;

          // central, shared node of neighbor [edge or face]
          node_mult[ix_ox3][ix_ox2][ix_ox1] += 1;

          if (nb_t == NeighborConnect::face) {
            // two of {ox1, ox2, ox3} == 0
            // remainder non-zero
            printf("f: (ox1, ox2, ox3, l)=(%d, %d, %d, %d)\n",
                   nb.ni.ox1, nb.ni.ox2, nb.ni.ox3,
                   pmb->pbval->nblevel[ix_ox3][ix_ox2][ix_ox1]);

          } else if (nb_t == NeighborConnect::edge) {
            // one of ox1 == 0 | ox2 == 0 | ox3 == 0
            // remainder non-zero

            printf("e: (ox1, ox2, ox3, l)=(%d, %d, %d, %d)\n",
                   nb.ni.ox1, nb.ni.ox2, nb.ni.ox3,
                   pmb->pbval->nblevel[ix_ox3][ix_ox2][ix_ox1]);

            node_mult[ix_ox3][ix_ox2][ix_ox1] += 1;
            if (nb.ni.ox1 == 0) {
              node_mult[ix_ox3][ix_ox2][ix_ox1-1] += 1;
              node_mult[ix_ox3][ix_ox2][ix_ox1+1] += 1;
            }

          } else if (nb_t == NeighborConnect::corner) {
            //
            printf("c: (ox1, ox2, ox3, l)=(%d, %d, %d, %d)\n",
                   nb.ni.ox1, nb.ni.ox2, nb.ni.ox3,
                   pmb->pbval->nblevel[ix_ox3][ix_ox2][ix_ox1]);

            // node_mult[ix_ox3][ix_ox2][ix_ox1] += 1;
          }

        }

      }

      // coutBoldRed("MB::UWIL gid = ");
      // printf("%d\n", pmb->gid);
      // if(pmb->gid == 4)
      //   Q();

      // apply conditions
      for (int k=0; k<=2; k++) {
        for (int j=0; j<=2; j++) {
          for (int i=0; i<=2; i++) {
            int nblev = pmb->pbval->nblevel[k][j][i];
            //int nb_t = pmb->pbval->ni

            int ix_cnr = ng + i * bh_nx1;
            int jx_cnr = ng + j * bh_nx2;
            int kx_cnr = ng + k * bh_nx3;

            if (mylevel <= nblev) {
              int ox1 = i-1, ox2 = j-1, ox3 = k-1;
              // int sgn_ox1 = (ox1 < 0) ? -1 : 1;
              // int sgn_ox2 = (ox2 < 0) ? -1 : 1;
              // int sgn_ox3 = (ox3 < 0) ? -1 : 1;


            }

          }
        }
      }


      // int b_nx1 = pmb->block_size.nx1;
      // int b_nx2 = pmb->block_size.nx2;
      // int b_nx3 = pmb->block_size.nx3;

      // iterate over neighbors applying consistency conditions
      for (int n=0; n<pbval_->nneighbor; n++) {
        NeighborBlock& nb = pbval_->neighbor[n];
        int ox1 = nb.ni.ox1, ox2 = nb.ni.ox2, ox3 = nb.ni.ox3;

        // neighbor level and connect type
        // int (*ptr_nblev)[3][3][3] = &(pmb->pbval->nblevel);
        // int nblev = *ptr_nblev[ox3 + 1][ox2 + 1][ox1 + 1];
        int nblev = pmb->pbval->nblevel[ox3 + 1][ox2 + 1][ox1 + 1];

        NeighborConnect nb_t = nb.ni.type;

        // ignore coarser neighbors
        if (mylevel > nblev)
          continue;

        int ix_cnr = ng + (ox1 + 1) * bh_nx1;
        int jx_cnr = ng + (ox2 + 1) * bh_nx2;
        int kx_cnr = ng + (ox3 + 1) * bh_nx3;

        int si = pmb->iis, ei = pmb->iie;
        int sj = pmb->jis, ej = pmb->jie;
        int sk = pmb->kis, ek = pmb->kie;

        if (nb_t == NeighborConnect::face) {
          // two of {ox1, ox2, ox3} must be zero
          // categorize based on non-zero index

          if (ox1 != 0)
            si = ei = (ox1 < 0) ? pmb->ivs : pmb->ive;

          if (ox2 != 0)
            sj = ej = (ox2 < 0) ? pmb->jvs : pmb->jve;

          if (ox3 != 0)
            sk = ek = (ox3 < 0) ? pmb->kvs : pmb->kve;


        } else if (nb_t == NeighborConnect::edge) {
          // one of {ox1, ox2, ox3} must be zero
          if (ox1 == 0) {

            //.
          }
        } else {
          // .
        }
        if (mylevel <= nblev)
          for (int n_=nl_; n_<=nu_; ++n_) {
            for (int k=sk; k<=ek; ++k) {
              for (int j=sj; j<=ej; ++j) {
                for (int i=si; i<=ei; ++i) {
                  //var(n_, k, j, i) /= 2.;
                }
              }
            }
          }

        if (nb_t == NeighborConnect::edge) {
          // one of {ox1, ox2, ox3} must be zero

        }

        if (nb_t == NeighborConnect::corner) {
          // none of {ox1, ox2, ox3} can be zero
          int sgn_ox1 = (ox1 < 0) ? -1 : 1;
          int sgn_ox2 = (ox2 < 0) ? -1 : 1;
          int sgn_ox3 = (ox3 < 0) ? -1 : 1;


          for (int n_=nl_; n_<=nu_; ++n_) {
            for (int jx=1; jx<=ng; jx++) {
              for (int ix=1; ix<=ng; ix++) {
                // var(n_, kx_cnr, jx_cnr + sgn_ox2 * jx, ix_cnr + sgn_ox1 * ix) /= 2.;
                // var(n_, kx_cnr + sgn_ox3 * jx, jx_cnr + sgn_ox2 * ix, ix_cnr) /= 2.;
                // var(n_, kx_cnr + sgn_ox3 * jx, jx_cnr, ix_cnr + sgn_ox1 * ix) /= 2.;
              }
            }
          }


        }


      }

    } else if (pmb->block_size.nx2 > 1) {

      int ng = NGHOST;
      int bh_nx1 = pmb->block_size.nx1 / 2;
      int bh_nx2 = pmb->block_size.nx2 / 2;

      for (int n=0; n<pbval_->nneighbor; n++) {
        // BD: debug
        coutMagenta("iterating over neighbors; (n, pbval_->nneighbor)=");
        printf("(%d, %d)\n", n, pbval_->nneighbor);
        //--

        NeighborBlock& nb = pbval_->neighbor[n];
        int ox1 = nb.ni.ox1, ox2 = nb.ni.ox2;

        // infer information about shared vertex multiplicity

        // common to same and finer
        if (mylevel <= nb.snb.level) {
          // neighbor at the same or finer level

          // retain the type of neighbor connect
          nb_type[0][ox2 + 1][ox1 + 1] = nb.ni.type;

          // retain refinement information
          nb_fi1[0][ox2 + 1][ox1 + 1] = nb.ni.fi1;

          // central, shared node of neighbor [edge or face]
          node_mult[0][ox2 + 1][ox1 + 1] += 1;

          // north-south contributions to 2d corner
          if (ox1 == 0) {
            node_mult[0][ox2 + 1][0] += 1;
            node_mult[0][ox2 + 1][2] += 1;

            // finer level -> only one "sub-block"
            if (mylevel < nb.snb.level) {
              if (nb.ni.fi1 == 1) {
                node_mult[0][ox2 + 1][0] -= 1;
              } else {
                node_mult[0][ox2 + 1][2] -= 1;
              }
            }
          }

          // east-west
          if (ox2 == 0) {
            node_mult[0][0][ox1 + 1] += 1;
            node_mult[0][2][ox1 + 1] += 1;

            // finer level -> only one "sub-block"
            if (mylevel < nb.snb.level) {
              if (nb.ni.fi1 == 1) {
                node_mult[0][0][ox1 + 1] -= 1;
              } else {
                node_mult[0][2][ox1 + 1] -= 1;
              }
            }
          }

        }
      }

      // apply conditions

      for (int j=0; j<=2; j++) {
        for (int i=0; i<=2; i++) {
          int nblev = pmb->pbval->nblevel[1][j][i];

          int ix_cnr = ng + i * bh_nx1;
          int jx_cnr = ng + j * bh_nx2;

          // apply conditions on internal shared centers
          if (node_mult[0][j][i] > 1) {
            for (int n_=nl_; n_<=nu_; ++n_) {
              var(n_, 0, jx_cnr, ix_cnr) /= node_mult[0][j][i];
            }
          }

          if (mylevel <= nblev) {
            int ox1 = i-1, ox2 = j-1;
            int sgn_ox1 = (ox1 < 0) ? -1 : 1;
            int sgn_ox2 = (ox2 < 0) ? -1 : 1;

            if (nb_type[0][j][i] == NeighborConnect::edge) {
              for (int n_=nl_; n_<=nu_; ++n_) {
                for (int ix=1; ix<=ng; ix++) {
                  var(n_, 0, jx_cnr, ix_cnr + sgn_ox1 * ix) /= 2.;
                  var(n_, 0, jx_cnr + sgn_ox2 * ix, ix_cnr) /= 2.;
                }
              }
            } else if (nb_type[0][j][i] == NeighborConnect::face) {

              if (ox1 == 0) {
                for (int n_=nl_; n_<=nu_; ++n_) {
                  for (int ix=1; ix<bh_nx1; ix++) {
                    var(n_, 0, jx_cnr, ix_cnr - ix) /= 2.;
                    var(n_, 0, jx_cnr, ix_cnr + ix) /= 2.;
                  }
                }

              } else { // ox1 != 0 and ox2 = 0
                for (int n_=nl_; n_<=nu_; ++n_) {
                  for (int ix=1; ix<bh_nx2; ix++) {
                    var(n_, 0, jx_cnr - ix, ix_cnr) /= 2.;
                    var(n_, 0, jx_cnr + ix, ix_cnr) /= 2.;
                  }
                }

              }

              if (mylevel < nblev) {
                if (ox1 == 0) {
                  for (int n_=nl_; n_<=nu_; ++n_) {
                    for (int ix=1; ix<=ng; ix++) {
                      var(n_, 0, jx_cnr + sgn_ox2 * ix, ix_cnr) /= 2.;
                    }
                  }

                } else { // ox1 != 0 and ox2 = 0
                  for (int n_=nl_; n_<=nu_; ++n_) {
                    for (int ix=1; ix<=ng; ix++) {
                      var(n_, 0, jx_cnr, ix_cnr + sgn_ox1 * ix) /= 2.;
                    }
                  }

                }


              }

            }

          }

        }
      }


    } else {
      // 1d
      for (int n=0; n<pbval_->nneighbor; n++) {
        // Same and finer level neighbours additively unpack;
        // this leads to nodes with multiplicity

        NeighborBlock& nb = pbval_->neighbor[n];
        if (mylevel <= nb.snb.level) {
          if (nb.ni.ox1 < 0) {   // nb is leftward (correct on each cpt.)
            for (int n_=nl_; n_<=nu_; ++n_) {
              var(n_, 0, 0, pmb->ivs) /= 2.;
            }
          } else {               // nb is rightward
            for (int n_=nl_; n_<=nu_; ++n_) {
              var(n_, 0, 0, pmb->ive) /= 2.;
            }
          }

        }

      }

    }


  printf("{{{\n");
  //var.print_all("%1.1f");

  // [k,j,i]
  for (int k=pmb->kms; k<=pmb->kpe; ++k) {
    printf("\nk=%d:\n", k); // slab for readability
    for (int j=pmb->jms; j<=pmb->jpe; ++j) {
      for (int i=pmb->ims; i<=pmb->ipe; ++i) {
        printf("%1.1f, ", var(0, k, j, i));
      }
      printf("\n");
    }
  }

  // [j,i,k]
  // for (int j=pmb->jms; j<=pmb->jpe; ++j) {
  //   printf("\nj=%d:\n", j); // slab for readability
  //   for (int i=pmb->ims; i<=pmb->ipe; ++i) {
  //     for (int k=pmb->kms; k<=pmb->kpe; ++k) {
  //       printf("%1.1f, ", var(0, k, j, i));
  //     }
  //     printf("\n");
  //   }
  // }

  // [i,k,j]
  // for (int i=pmb->ims; i<=pmb->ipe; ++i) {
  //   printf("\ni=%d:\n", i); // slab for readability
  //   for (int k=pmb->kms; k<=pmb->kpe; ++k) {
  //     for (int j=pmb->jms; j<=pmb->jpe; ++j) {
  //       printf("%1.1f, ", var(0, k, j, i));
  //     }
  //     printf("\n");
  //   }
  // }

  // flip idx for readability
  // var.print_all("%1.1f", false, true);
  // coarse_var.print_all();
  // if (mylevel == 2)
  // Q();

  coutBoldRed("MB::UWIL gid = ");
  printf("%d\n", pmb->gid);

  // printf("x1f: ");
  // pmb->pcoord->x1f.print_data("%1.2f");
  // printf("x2f: ");
  // pmb->pcoord->x2f.print_data("%1.2f");

  /////////////////////////////
  // printf("node_mult: \n");

  int kmax = (pmb->block_size.nx3 > 1) ? 2 : 0;
  // for (int k=0; k<=kmax; k++) {
  //   int kk = 0;
  //   if (pmb->block_size.nx3 > 1) {
  //     printf("\nk=%d:\n", k); // slab for readability
  //     kk = k;
  //   }

  //   for (int j=0; j<=2; j++) {
  //     for (int i=0; i<=2; i++) {
  //       printf("%d, ", node_mult[kk][j][i]);
  //     }
  //     printf("\n");
  //   }
  // }
  /////////////////////////////


  /////////////////////////////
  printf("pbvals->nblevel\n");

  for (int k=0; k<=kmax; k++) {
    int kk = 1;
    if (pmb->block_size.nx3 > 1) {
      printf("\nk=%d:\n", k); // slab for readability
      kk = k;
    }

    for (int j=0; j<=2; j++) {
      for (int i=0; i<=2; i++) {
        printf("%d, ", pmb->pbval->nblevel[kk][j][i]);
        // if (pmb->pbval->nblevel[1][j][i] == -1) {
        //   Q();
        // }
      }
      printf("\n");
    }
  }

  // reorder
  for (int j=0; j<=2; j++) {
    printf("\nj=%d:\n", j); // slab for readability
    for (int k=0; k<=2; k++) {
      for (int i=0; i<=2; i++) {
        printf("%d, ", pmb->pbval->nblevel[k][j][i]);
      }
      printf("\n");
    }
  }

  // reorder
  for (int i=0; i<=2; i++) {
    printf("\ni=%d:\n", i); // slab for readability
    for (int k=0; k<=2; k++) {
      for (int j=0; j<=2; j++) {
        printf("%d, ", pmb->pbval->nblevel[k][j][i]);
      }
      printf("\n");
    }
  }


  /////////////////////////////
  coutMagenta("mylevel: ");
  printf("%d\n", mylevel);

  // filter error on subsets of meshblock

  for (int k=pmb->kvs; k<=pmb->kvs; k++) {
    printf("\nk=%d:\n", k); // slab for readability
    for (int j=pmb->jms; j<=pmb->jpe; j++) {
      for (int i=pmb->ims; i<=pmb->ipe; i++) {
        printf("%1.1f, ", var(0, k, j, i));
        if (std::abs(var(0, k, j, i) - 1.) > 0.001) {
          coutBoldRed("\n\nerror found:");
          printf(" @ (%d,%d,%d)\n\n",
                 k, j, i);
          coutBoldRed("MB::UWIL gid = ");
          printf("%d\n", pmb->gid);
          Q();

        }
      }
      printf("\n");
    }
  }

  // if(pmb->gid == 1)
  //   Q();

  // if(pmb->gid == 38)
  //   Q();

  // if(pmb->gid == 351)
  //   Q();
  // if(pmb->gid == 3)
  //   Q();
  // if(pmb->gid == 349)
  //   Q();

  // analyse top-cap
  // if(pmb->gid == 494)
  //   Q();

  // ox3 == -1
  // if(pmb->gid == 494)
  //   Q();

  // ox3 == +1
  // if(pmb->gid == 3)
  //   Q();

  // ox2 == +1
  // if(pmb->gid == 5)
  //   Q();

  // ox2 == -1
  // if(pmb->gid == 362)
  //   Q();

  // ox1 == -1
  // if(pmb->gid == 267)
  //   Q();

  // ox1 == +1
  // if(pmb->gid == 6)
  //   Q();

  // if(pmb->gid == 4)
  //   Q();
  printf("}}}\n");
  return;
}

//----------------------------------------------------------------------------------------
//! \fn void VertexCenteredBoundaryVariable::PolarBoundarySingleAzimuthalBlock()
// \brief polar boundary edge-case: single MeshBlock spans the entire azimuthal (x3) range

void VertexCenteredBoundaryVariable::PolarBoundarySingleAzimuthalBlock() {
  coutYellow("VertexCenteredBoundaryVariable::PolarBoundarySingleAzimuthalBlock\n");
  return;
}

void VertexCenteredBoundaryVariable::SetupPersistentMPI() {
#ifdef MPI_PARALLEL
  coutYellow("VertexCenteredBoundaryVariable::SetupPersistentMPI\n");
  MeshBlock* pmb = pmy_block_;
  int &mylevel = pmb->loc.level;

  int f2 = pmy_mesh_->f2, f3 = pmy_mesh_->f3;
  int cng, cng1, cng2, cng3;
  cng  = cng1 = pmb->cnghost;
  cng2 = cng*f2;
  cng3 = cng*f3;
  int ssize, rsize;
  int tag;
  // Initialize non-polar neighbor communications to other ranks
  for (int n=0; n<pbval_->nneighbor; n++) {
    NeighborBlock& nb = pbval_->neighbor[n];
    if (nb.snb.rank != Globals::my_rank) {
      if (nb.snb.level == mylevel) { // same
        ssize = rsize = ((nb.ni.ox1 == 0) ? pmb->block_size.nx1 : NGHOST)
              *((nb.ni.ox2 == 0) ? pmb->block_size.nx2 : NGHOST)
              *((nb.ni.ox3 == 0) ? pmb->block_size.nx3 : NGHOST);
      } else if (nb.snb.level < mylevel) { // coarser
        ssize = ((nb.ni.ox1 == 0) ? ((pmb->block_size.nx1 + 1)/2) : NGHOST)
              *((nb.ni.ox2 == 0) ? ((pmb->block_size.nx2 + 1)/2) : NGHOST)
              *((nb.ni.ox3 == 0) ? ((pmb->block_size.nx3 + 1)/2) : NGHOST);
        rsize = ((nb.ni.ox1 == 0) ? ((pmb->block_size.nx1 + 1)/2 + cng1) : cng1)
              *((nb.ni.ox2 == 0) ? ((pmb->block_size.nx2 + 1)/2 + cng2) : cng2)
              *((nb.ni.ox3 == 0) ? ((pmb->block_size.nx3 + 1)/2 + cng3) : cng3);
      } else { // finer
        ssize = ((nb.ni.ox1 == 0) ? ((pmb->block_size.nx1 + 1)/2 + cng1) : cng1)
              *((nb.ni.ox2 == 0) ? ((pmb->block_size.nx2 + 1)/2 + cng2) : cng2)
              *((nb.ni.ox3 == 0) ? ((pmb->block_size.nx3 + 1)/2 + cng3) : cng3);
        rsize = ((nb.ni.ox1 == 0) ? ((pmb->block_size.nx1 + 1)/2) : NGHOST)
              *((nb.ni.ox2 == 0) ? ((pmb->block_size.nx2 + 1)/2) : NGHOST)
              *((nb.ni.ox3 == 0) ? ((pmb->block_size.nx3 + 1)/2) : NGHOST);
      }
      ssize *= (nu_ + 1); rsize *= (nu_ + 1);
      // specify the offsets in the view point of the target block: flip ox? signs

      // Initialize persistent communication requests attached to specific BoundaryData
      // vertex-centered hydro: bd_hydro_
      tag = pbval_->CreateBvalsMPITag(nb.snb.lid, nb.targetid, cc_phys_id_);
      if (bd_var_.req_send[nb.bufid] != MPI_REQUEST_NULL)
        MPI_Request_free(&bd_var_.req_send[nb.bufid]);
      MPI_Send_init(bd_var_.send[nb.bufid], ssize, MPI_ATHENA_REAL,
                    nb.snb.rank, tag, MPI_COMM_WORLD, &(bd_var_.req_send[nb.bufid]));
      tag = pbval_->CreateBvalsMPITag(pmb->lid, nb.bufid, cc_phys_id_);
      if (bd_var_.req_recv[nb.bufid] != MPI_REQUEST_NULL)
        MPI_Request_free(&bd_var_.req_recv[nb.bufid]);
      MPI_Recv_init(bd_var_.recv[nb.bufid], rsize, MPI_ATHENA_REAL,
                    nb.snb.rank, tag, MPI_COMM_WORLD, &(bd_var_.req_recv[nb.bufid]));

      // hydro flux correction: bd_var_flcor_
      if (pmy_mesh_->multilevel && nb.ni.type == NeighborConnect::face) {
        int size;
        if (nb.fid == 0 || nb.fid == 1)
          size = ((pmb->block_size.nx2 + 1)/2)*((pmb->block_size.nx3 + 1)/2);
        else if (nb.fid == 2 || nb.fid == 3)
          size = ((pmb->block_size.nx1 + 1)/2)*((pmb->block_size.nx3 + 1)/2);
        else // (nb.fid == 4 || nb.fid == 5)
          size = ((pmb->block_size.nx1 + 1)/2)*((pmb->block_size.nx2 + 1)/2);
        size *= (nu_ + 1);
        if (nb.snb.level < mylevel) { // send to coarser
          tag = pbval_->CreateBvalsMPITag(nb.snb.lid, nb.targetid, cc_flx_phys_id_);
          // if (bd_var_flcor_.req_send[nb.bufid] != MPI_REQUEST_NULL)
          //   MPI_Request_free(&bd_var_flcor_.req_send[nb.bufid]);
          // MPI_Send_init(bd_var_flcor_.send[nb.bufid], size, MPI_ATHENA_REAL,
          //               nb.snb.rank, tag, MPI_COMM_WORLD,
          //               &(bd_var_flcor_.req_send[nb.bufid]));
        } else if (nb.snb.level > mylevel) { // receive from finer
          tag = pbval_->CreateBvalsMPITag(pmb->lid, nb.bufid, cc_flx_phys_id_);
          if (bd_var_flcor_.req_recv[nb.bufid] != MPI_REQUEST_NULL)
            MPI_Request_free(&bd_var_flcor_.req_recv[nb.bufid]);
          MPI_Recv_init(bd_var_flcor_.recv[nb.bufid], size, MPI_ATHENA_REAL,
                        nb.snb.rank, tag, MPI_COMM_WORLD,
                        &(bd_var_flcor_.req_recv[nb.bufid]));
        }
      }
    }
  }
#endif
  return;
}

void VertexCenteredBoundaryVariable::StartReceiving(BoundaryCommSubset phase) {
#ifdef MPI_PARALLEL
  coutYellow("VertexCenteredBoundaryVariable::StartReceiving\n");

  MeshBlock *pmb = pmy_block_;
  int mylevel = pmb->loc.level;
  for (int n=0; n<pbval_->nneighbor; n++) {
    NeighborBlock& nb = pbval_->neighbor[n];
    if (nb.snb.rank != Globals::my_rank) {
      MPI_Start(&(bd_var_.req_recv[nb.bufid]));
      // if (phase == BoundaryCommSubset::all && nb.ni.type == NeighborConnect::face
      //     && nb.snb.level > mylevel) // opposite condition in ClearBoundary()
      //   MPI_Start(&(bd_var_flcor_.req_recv[nb.bufid]));
    }
  }
#endif
  return;
}


void VertexCenteredBoundaryVariable::ClearBoundary(BoundaryCommSubset phase) {
  coutYellow("VertexCenteredBoundaryVariable::ClearBoundary\n");
  for (int n=0; n<pbval_->nneighbor; n++) {
    NeighborBlock& nb = pbval_->neighbor[n];
    bd_var_.flag[nb.bufid] = BoundaryStatus::waiting;
    bd_var_.sflag[nb.bufid] = BoundaryStatus::waiting;

    // if (nb.ni.type == NeighborConnect::face) {
    //   bd_var_flcor_.flag[nb.bufid] = BoundaryStatus::waiting;
    //   bd_var_flcor_.sflag[nb.bufid] = BoundaryStatus::waiting;
    // }
#ifdef MPI_PARALLEL
    MeshBlock *pmb = pmy_block_;
    int mylevel = pmb->loc.level;
    if (nb.snb.rank != Globals::my_rank) {
      // Wait for Isend
      MPI_Wait(&(bd_var_.req_send[nb.bufid]), MPI_STATUS_IGNORE);
      // if (phase == BoundaryCommSubset::all && nb.ni.type == NeighborConnect::face
      //     && nb.snb.level < mylevel)
      //   MPI_Wait(&(bd_var_flcor_.req_send[nb.bufid]), MPI_STATUS_IGNORE);
    }
#endif
  }

// VC
//   // clear shearing box boundary communications
//   if (SHEARING_BOX) {
//     // TODO(KGF): clear sflag arrays
//     for (int upper=0; upper<2; upper++) {
//       if (pbval_->is_shear[upper]) {
//         for (int n=0; n<4; n++) {
//           if (pbval_->shear_send_neighbor_[upper][n].rank == -1) continue;
//           shear_bd_var_[upper].flag[n] = BoundaryStatus::waiting;
// #ifdef MPI_PARALLEL
//           if (pbval_->shear_send_neighbor_[upper][n].rank != Globals::my_rank) {
//             MPI_Wait(&shear_bd_var_[upper].req_send[n], MPI_STATUS_IGNORE);
//           }
// #endif
//         }
//       }
//     }
//   }
  return;
}
